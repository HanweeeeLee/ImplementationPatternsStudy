# 05. 클래스
5장에서는 다음 패턴을 다룬다.
 - 클래스: "이 데이터들은 함께 사용되는데, 그에 관련된 로직이 이것이다"라는 이야기를 하고싶을 때 클래스를 사용한다.
 - 단순한 상위클래스 이름: 클래스 계층의 최상위에 위치하는 클래스 이름은 단순하게 짓는다.
 - 한정적 하위클래스 이름: 상위클래스와의 유사점과 차이점을 분명히 드러내는 이름을 사용한다.
 - 추상 인터페이스: 인터페이스와 구현을 분리한다.
 - 인터페이스: 자주 변하지 않는 추상 인터페이스에는 자바 인터페이스를 사용한다.
 - 버전 인터페이스: 하위인터페이스를 사용해 기존 인터페이스를 안전하게 확장한다.
 - 추상 클래스: 자주 바뀔 것 같은 추상 인터페이스에는 추상 클래스를 사용한다.
 - 값 객체: 산술값처럼 동작하는 객체를 사용한다.
 - 특화: 관련된 연산 사이의 유사점 및 차이점을 분명하게 나타낸다.
 - 하위클래스: 1차원적 변화는 하위클래스를 사용해서 표현한다.
 - 구현자(Implementor): 연산 내용이 바뀌었다면 기존 메소드를 오버라이드해서 사용한다.
 - 내부 클래스: 클래스 내부에서 유용하게 사용할 수 있는 코드를 모아 전용 클래스로 사용한다.
 - 인스턴스별 행동(instance-spexific behavior): 인스턴스에 따라 로직에 변화를 준다.
 - 조건문: 명시적 조건에 따라 로직에 변화를 준다.
 - 위임(delegate): 여러 종류의 객체 중에 하나에 위임해서 로직에 변화를 준다.
 - 플러그인 선택자(pluggable selector): 리플렉션을 이용한 메소드 호출로 로직에 변화를 준다.
 - 익명 내부 클래스: 필요한 메소드에서 한두 개의 메소드만 오버라이드하는 객체를 만들어서 사용한다.
 - 라이브러리 클래스: 마땅히 들어갈 곳이 없는 기능들을 묶어서 정적 메소드로 표현한다.

## 클래스
 - 클래스를 사용하는 이유는? 데이터가 로직에 비해 빈번하게 변화하기 때문!  
 - 클래스의 로직과 데이터는 함꼐 사용되며, 로직은 데이터에 비해 변화율이 낮다. 클래스 내부의 데이터는 관련 로직에 의해 변화하며, 클래스 내부에서 사용하는 데이터의 변화율은 비슷하다.  
 - 클래스의 계층을 구성하는것은 일종의 압축. 클래스 계층의 사용은 상위 계층의 코드를 하위에서 쓰는것이지만, 상위 클래스에 대해서 모두 이해해야만 한다.  
 - 효과적인 OOP를 하기 위한 다른 요건은 선별적으로 상속을 사용하는것.(override)  
 - 클래스는 비싼편이므로 의미있는 작업에만 클래스를 사용해야 한다.

## 단순한 상위클래스 이름
 - 적절한 이름은 코드를 단순화하고 향상시켜준다. 이름중에서 가장 중요한것은 클래스의 이름!
 - 클래스의 이름을 정할때 메타포(metaphor, 은유)를 사용해보자. 중요한 클래스에 대해서는 한 단어로 된 이름을 사용하는것이 좋다.

## 한정적 하위클래스 이름
 - 하위클래스 이름은 상위클래스와의 유사점과 차이점을 나타내야 한다. 
 - 보통은 상위클래스이름에 수식어를 붙히지만 자체로 프로그램의 중요한 개념을 의미한다면 그렇게 만들어서는 안된다. 
 - 클래스의 이름은 코드의 내용을 반영해야한다.

## 추상 인터페이스
 - 구현이 아니라 인터페이스에 맞춰 코딩하라
 - 인터페이스 추가에는 비용이 발생한다. 인터페이스를 배우고 이해하며 문서화하고 디버깅하고 정리하고 조회해서 적당한 이름을 지어야 한다.
 - 인터페이스 수를 최대한 늘린다고 해서 소프트웨어 비용이 최소화되는 것은 아니다. 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야 한다. 
 - 인터페이스를 사용하게 된 경제적 이유로는 소프트웨어는 예측하기 어렵다는 점이다. 

## 인터페이스
 -  자바 인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다"라고 이야기하는 것과 같다. 
 - 인터페이스를 사용하면 구현을 바꾸는 것은 쉽지마느, 인터페이스 자체를 바꾸기는 쉽지 않다. -> 인터페이스를 구현하는 모든 클래스를 수정해야 하기 때문!
 - 인터페이스에 이름을 짓는 방법은 크게 두가지가 있다. 1. 인터페이스를 구현이 빠져있는 클래스로 간주하는 경우, 클래스와 동일하게 2. 앞에 I를 붙힌다. ex) IFile

## 추상 클래스
 - 추상 클래스와 자바 인터페이스의 장단점은 인터페이스 수정의 용의성과 단일 클래스가 여러 인터페이스를 지원할 수 있는지의 여부
 - 자바 인터페이스는 인터페이스 수정에 매우 취약하다. 하지만 추상클래스에는 이런 문제가 없다. 기존설계를 망가트리지 않고 새로운 연산을 추가할 수 있다.
 - 추상클래스의 단점은 각 클래스가 단 1개의 상위클래스만을 지정할 수 있다는 것이다. 

## 버전 인터페이스
 - 인터페이스를 바꾸고 싶은데, 바꿀 수 없는 경우에는? 인터페이스에 어떤 연산을 추가하고 싶을 때...
 - 새로운 인터페이스를 선언해서 기존 인터페이스를 확장(상속)한 후 새로운 연산을 추가할 수는 있다.
ex)
```Java
interface Command {
    void run();
}
```
> 이 인터페이스가 공개되고 널리 사용된 상황에서 인터페이스를 바꿀 경우, 수정 비용이 엄청날 것이다.  
  
```Java
interface ReversibleCommand extends Command {
    void undo();
}
```
> 이렇게 하면 해결 가능. 

```Java
Command recent = ...;
if (recent instanceof ReversibleCommand) {
    ReversibleCommand downcasted = (ReversibleCommand) recent;
    downcasted.undo();
}
```
> 이렇게 사용 할 수 있다. 

instanceof를 사용하는 경우, 코드가 특정 클래스에 제한되므로 유연성이 떨어진다. 하지만 이 경우에는 인터페이스를 개선할 수 있으므로 사용이 정당화된다.  
각 변형에 대해서는 별도의 로직이 필요하다. 따라서 새로 확장한 대체 인터페이스의 수가 많아지면 클라이언트가 할 일이 크게 늘어난다. 이는 설계를 수정할 떄가 되었다는 신호다.  
대체 인터페이스는 달갑지 않은 문제에 대한 달갑지 않은 해결책이다.  


## 값 객체
```Java
class Transaction {
    int value;
    Transaction(int value, Account credit, Account debit) {
        this.value = value;
        credit.addCredit(this);
        debit.addDebit(this);
    }
}
```
Transaction 객체의 경우, 일단 생성된 후에는 값을 변경하는 것이 불가능하다. 객체 생성 시 생성자는 2개의 Account 객체를 모두 업데이트 해준다. 따라서 이 코드를 보면 거래가 중간에 중단되는 경우나 거래 금액이 나중에 바뀌는 경우를 미리 걱정할 필요가 없다는 것을 알 수 있다.  
  
이렇게 값 스타일 객체(변화하는 상태를 지닌 객체가 아닌 정수와 같은 객체)를 구현하려면, 먼저 상태를 가지고 있는 세계와 값으로만 구성된 세계를 구별해야 한다.  
위의 예에서 Transaction은 값 스타일 객체이고, Account는 변화하는 상태를 가진 객체다.  
값 스타일 객체에서는 생성자에서만 모든 상태를 설정할 뿐, 다른 경로를 통해서는 필드 값을 변경하면 안된다.  
값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다. 이러한 객체는 연산을 요청한 쪽에서 저장한다.  
```Java
bounds.translateBy(10, 20); // 변경 가능한 Rectangle 객체  
bounds = bounds.translateBy(10, 20); // 값 스타일 Rectangle 객체  
```
하지만 상태로 된 부분과 값으로 된 부분을 구별하기 쉽지 않다.  

## 특화
 - 연산 간의 유사점과 차이점을 부각시키는 방향으로 코드를 작성하면, 프로그램을 읽고 사용하고 수정하기 쉬워진다.  
 - 특화를 시키면 수정이 필요한 경우 기존 코드를 변형해서 특화하는 것이 좋을지 완전히 새로운 코드를 짜는 것이 좋을지 판단할 수 있다. 

## 하위클래스
 - 하위 클래스를 선언하는 것은 "이 객체는 상위클래스와 같다. 이 부분만 제외하면..."이라 말하는 것과 같다. 
 - 하위클래스의 문제점: 1. 하위클래스를 사용하면 되돌리기가 쉽지 않다. 2. 하위클래스를 이해하기 위해서는 먼저 상위클래스를 이해해야 한다. 3. 하위클래스가 상위클래스 세부 구현 특성에 의존할 수 있으므로 상위클래스 수정이 위험해진다. 4. 클래스 상속 계층이 복잡해지면 이 모든 문제가 심화된다.
 - 상속을 사용할 떄 특히 치명적인 문제는 병렬 클래스 계층을 이용하는 경우이다. 하나의 클래스 계층에 있는 각 하위 클래스에 대해 다른 클래스 계층에 대응되는 하위 클래스가 필요하다. 이건 중복!

![KakaoTalk_Photo_2022-02-12-22-54-25](https://user-images.githubusercontent.com/60125719/153714197-f25842e3-90d2-4e4d-a663-53b232e795cc.jpeg)
> 보험 계약은 연금 상품을 참조하면 안된다. 그렇다고 계약 클래스에서 상품을 참조하게 하는것도 별로다.

![KakaoTalk_Photo_2022-02-12-22-54-28](https://user-images.githubusercontent.com/60125719/153714240-64563c42-0845-4916-a27b-f396a59d8bac.jpeg)
> 계약 클래스가 보험 상품이나 연금 상품에 상관 없이 동작하게 만들었다.

 - 이런 문제점을 알고 있다면, 하위클래스는 연산의 다양한 변형을 나타낼 수 있는 강력한 도구다. 하위클래스를 올바르게 사용하기 위한 키 포인트는 상위클래스의 로직을 여러 개의 메소드로 쪼개는 것이다.

## 구현자(Implementor)
 - OOP에서 선택을 표현하기 위해 주로 다형적 메시지(polymorphic message)를 사용한다. 메시지로 선택을 표현하기 위해서는 여러 종류의 다양한 객체가 메시지를 받아서 처리하게 된다.
 - 다형적 메시지는 여러 가지 변형을 수용할 수 있다. ex) 프로그램이 다른 시스템에 일련의 데이터를 전송하는 경우, 추상 클래스 Socket을 사용하면 호출하는 코드에 영향을 주지 않고 소켓의 구현을 자유롭게 바꿀 수 있다. 

  
## 내부 클래스
 - 어떤 연산을 표현하기 위한 클래스가 필요하지만 새로운 파일에 완전히 클래스를 만들고 싶지 않을 때 쓰자
 - 내부 클래스는 Object 객체만을 상속하는 경우도 있지만 상위클래스를 상속하기도 하는데, 이는 클래스 내부의 사용을 위해 기존 클래스를 약간 수정하는 경우 좋다.

## 인스턴스별 행동(instance-spexific behavior)
 - 이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다.
 - 인스턴스별로 다른 행동을 보이는 경우, 특정 인스턴스의 행동을 이해하기 위해서는 실례를 보거나 데이터의 흐름을 분석해야만 한다.
 - 연산 수행 도중에 로직이 변하는 경우, 인스턴스별 행동에 따른 비용은 더욱 커진다. **코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 말자.**

## 조건문
 - 조건문을 사용하면 인스턴스 행동을 변경하기 위해 해당 클래스 코드를 고쳐야 한다.
 - 프로그램의 각 경로가 모두 독립적이라고 전제할 경우, 프로그램 수행 경로가 많으면 프로그램에 문제가 있을 확률이 높다. -> 조건문의 수가 많으면 프로그램의 안정성이 떨어진다. 조건문이 복사되면 심각...

## 위임(delegate)
 - 각 인스턴스에서 다른 로직을 수행하도록 하는 방법으로 위임이 있다. 


```Java
 public void mouseDown() {
    switch (getTool()) {
        case SELECTING: 
            //...
            break;
        case CREATING_RECTANGLE: 
            //...
            break;
        case EDITING_TEXT: 
            //...
            break;
        default:
            break;
    }
 }
```
> 새로운 도구를 추가하면 코드를 수정해야 하고, 조건문의 중복(mouseUp(), mouseMove())으로 인해 도구를 새로 추가하기 어렵다.

```Java
public void mouseDown() {
    getTool().mouseDown();
}
```
> delegate패턴으로 유연성을 부여할 수 있다.

 - 위임은 인스턴스 별 행동을 지원할 뿐 아니라 코드 공유에도 사용할 수 있다.

```Java
GraphicEditor
public void mouseDown() {
    tool.mouseDown(this);
}

RectangleTool
public void mouseDown(GraphicEditor editor) {
    editor.add(new RectangleFigure);
}
```
> 이런식으로 사용 가능

## 플러그인 선택자(pluggable selector)
 -  한두개의 메소드에서만 인스턴스별 행동이 필요하며, 모든 로직이 하나의 클래스 않에 들어가도 좋은 경우, 메소드 이름을 필드에 저장해 두고, 리플렉션(reflection)을 통해 메소드를 호출하는 것도 좋다.

## 익명 내부 클래스
인스턴스별 행동을 위해 자바가 지원하는 다른 기법은 익명 내부 클래스다.  
익명 내부 클래스의 기본 아이디어는 한 곳에서만 사용되는 클래스를 생성해서 일부 메소드를 오버라이드 한 후, 지역적으로만 사용하는 것이다. 특정 지역에서만 사용되므로 이러한 클래스는 이름이 필요없다. 

## 라이브러리 클래스
어떤 객체에도 적합하지 않은 기능은 빈 클래스를 하나 만들어서 정적 메소드로 구현하는 것이다.  
라이브러리 클래스는 인스턴스화가 불가능한, 라이브러리 메소드만을 갖고 있는 클래스다.  
가능하면 라이브러리 클래스는 객체로 변환하는것이 좋다.  
라이브러리 클래스를 점진적으로 객체로 바꾸기 위해서는 정적 메소드를 인스턴스 메소드로 바꾸면 된다.


