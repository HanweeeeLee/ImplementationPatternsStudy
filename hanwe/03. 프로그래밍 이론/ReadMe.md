# 03. 프로그래밍 이론
아무리 많은 패턴을 늘어놓더라도 프로그래밍을 하면서 생기는 모든 상황을 커버할 수는 없다. 결국(사실 꽤 자주) 어떠한 정형화된 패턴도 적용할 수 없는 경우를 맞게 될 것이다. 프로그래밍 이론은 새로운 문제가 발생해도 해결책을 찾을 수 있도록 도와준다.  
  
각 패턴에서 설명하는 이론 외에도 결정 사항에 영향을 미치는 많은 동력(force)이 존재한다. 여기서는 동력을 가치(value)와 원칙(principle)의 두 가지로 나눈다.  
가치, 원칙, 패턴을 사용하면 균형 있는 개발 스타일을 얻을 수 있다. 패턴은 지금 당장 무엇을 해야 할지를 알려주고, 가치는 패턴을 사용해야 하는 동기를 알려주며, 원칙은 동기를 행동으로 어떻게 바꿔줄지 알려준다.  

## 가치
훌륭한 프로그래밍에 있어 공통적인 가치는 커뮤니케이션, 단순성, 유연성이다.  

### 커뮤니케이션
개발자가 코드를 쉽게 이해하고, 수정하고, 사용할 수 있다면, 그 코드는 개발자와 커뮤니케이션을 하고 있다고 이야기 할 수 있다.  
커뮤니케이션에 초점을 맞춰서 개발을 하면 경제적으로도 효과가 좋다. 코드는 새로 개발하는것보다 수정하는 데 걸린 시간이 더 크다. 따라서 내가 짜는 코드의 개발 비용을 줄이기 위해서 이해하기 쉬운 코드를 작성해야 한다.  

### 단순성
복잡도를 낮추면 프로그램을 읽고 사용하고 수정하는 사람들이 프로그램을 훨씬 빨리 이해할 수 있다. 복잡도가 과다하게 높아지면 소프트웨어가 제대로 동작하지 않게 되며, 수정도 어려워저 소프트웨어의 가치가 떨어진다. 프로그래밍을 할 때 해야 할 일 중 하나는 지금까지 짜 놓은 코드를 보고 불필요한 부분을 제거하는 것이다.  
  
프로그램을 최대한 단순화하라. 의미 없는 코드는 모두 제거하라. 설계시에도 과도한 요소는 모두 빼고, 요구사항을 분석해서 꼭 필요한 사항만을 뽑아내라. 과도한 복잡도를 제거하면 코드를 새로운 관점에서 바라볼 수 있다.  

### 유연성
유연성은 비효율적인 코딩이나 설계를 정당화해주는 가치이다. 프로그램은 유연해야 하지만, 프로그램이 발전하는 방향으로 유연해야 한다.  
프로그램 개발 비용은 대부분 처음 프로그램이 작성된 후부터 들어간다는 점을 생각해볼 때, 프로그램 수정은 가급적 쉬워야한다. 하지만 당장 필요할 것 같다고 생각했던 유연성이 사실 필요하지 않은 것으로 판명나는 경우도 많다. 따라서 추측에 의거해 설계에 유연성을 부열하는 것보다는 단순성을 유연하게 적용한 후 테스트를 철저하게 하는 편이 더욱 효과적이다.  
  
유연성이 있으면서도 당장 이득을 얻을 수 있는 패턴을 사용하라.  

유연성은 복잡도를 증가시킨다.  
  
커뮤니케이션을 중시하면 유연성도 좋아진다. 더욱 많은 사람들이 코드를 짧은 시간 안에 읽고 이해하고 수정할 수 있다면, 여러분의 조직이 미래에 취할 수 있는 전략의 폭도 넓어진다.  

## 원칙
구현 패턴은 그냥 나온 것이 아니다. 각 패턴은 커뮤니케이션, 단순성, 유연성의 가치 중 하나 이상을 내포하고 있다. 원칙은 가치에 비해 좀더 프로그래밍에 특화된 개념이지만, 가치와 마찬가지로 일반적인 생각을 담고 있으며, 패턴의 근간을 이룬다.  

### 지역적 변화
코드를 수정할 때 함께 바꿔야 하는 부분을 최소화하라. 프로그램의 어떤 부분을 수정한 것이 다른 부분에서 문제를 일으킨다면, 프로그램 수정에 대한 비용이 커진다. 지역적 변화만을 일이키는 코드는 커뮤니케이션이 쉽다.(관심사가 적기 때문)  
구현 패턴을 사용하는 중요한 이유는 프로그램 수정 비용을 낮추기 위함이므로, 지역적 변화(Local Consequences)의 원칙은 여러 패턴의 근간이 된다.  

### 최소 중복
지역적 변화를 돕는 다른 원칙은 최소 중복의 원칙이다. 중복된 코드가 많으면 많을수록 코드 수정은 어려워진다.  
프로그램상에 존재하는 중복에는 반복되는 코드 외에도 여러 가지가 있다. 병렬 클래스 계층(parallel class hierarchy)도 중복의 일종이다. 프로그램상의 어떤 개념을 수정했을 때 2개 이상의 클래스 계층을 수정해야 한다면, 이러한 수정은 지역적 변화의 원칙을 위배하는 것이다.  
  
중복을 없애는 한 가지 방법은 프로그램을 여러 작은 부분 (짧은 구문, 짧은 메소드, 작은 객체, 작은 패키지) 으로 나누는 것이다. 

### 로직과 데이터의 결합
로직과 데이터를 합께 유지하자. 데이터와 그 데이터를 처리하는 로직을 밀접하게(가급적 같은 메서드 혹은 같은 객체 내에, 최소한 같은 패키지 내부에)배치하라. 프로그램을 수정하는 경우, 로직과 데이터를 모두 고쳐야 할 경우가 많다.  
  
이 원칙을 따르기 위해 로직과 데이터를 어떤 식으로 배치해야 하는지에 대한 명확한 가이드라인은 없다. 때로는 효과적인 커뮤니케이션을 유지하면서 로직과 데이터를 함께 넣을 수 있는 방법을 찾기가 어려운 경우도 있다. 

### 대칭성
같은 객체 안에 있는 모든 필드는 함께 생성되어 함께 소멸된다. 프로그램에서 대칭성을 찾아내서 명확히 표현해주면, 코드를 읽기가 수월해진다.  
  
대칭성이 결여된 다음 코드를 보자
```Java
void process() {
    input();
    count++;
    output();
}
```
대칭성을 고려해서 코드를 수정하면 다음과 같다
```Java
input();
incrementCount();
output();
```
대칭성에 따르면 왜 카운터를 증가시키는지 생각해봐야 한다. 다시 코드를 바꾸면 다음과 같다
```Java
void process() {
    input();
    tally();
    output();
}
```

### 선언적 표현
명령형 프로그래밍은 강력하고 유연하지만 프로그램을 이해하기 위해서는 수행 흐름을 따라가야 한다. 다시 말해 머릿속에 컴퓨터의 수행 상태를 생각하면서, 제어 흐름과 데이터 흐름을 추적해야 프로그램을 제대로 이해할 수 있다.  
수행 순서가 중요한 구문이나 조건부 구문이 없는 일반 구문의 경우, 선언적 표현을 통해 코드를 작성하는 것이 이해하기 쉽다.  
  
```Java
public static junit.framework.Test suite() {
    Test result = new TestSuite();
    ...복잡한 구문...
    return result;
}
```
> suite()메서드는 단순히 여러 클래스에 흩어져 있는 테스트를 모아줄 뿐이다. 그러나 suite() 메서드는 범용이므로, 수행할 테스트를 확인하기 위해 실제 메서드 내부를 살펴보고 이해해야만 한다.

```Java
@RunWith(Suite.class)
@TestClasses({
    SimpleTest.class,
    ComplicatedTest.class
})
class AllTests {

}
```
> J유닛 4에서는 선언적 표현을 사용해서 이 문제를 해결했다. J유닛4는 여러 개의 테스트를 반환하는 메서드를 사용하는 대신, 여러 클래스에 있는 테스트를 수행해주는 특수한 테스트 수행 클래스를 사용한다.  

위와 같은 방식으로 수행될 테스트를 지정하면 TestClasses만 봐도 어떤 테스트가 수행될지 알 수 있다.  

### 변화율
함께 변하는 로직과 데이터를 함께 관리하고, 변화율이 다른 로직과 데이터는 분리하자. 변화율은 시간적 대칭성으로 볼 수 있다.  
  
변화율은 데이터에도 적용된다. 하나의 객체에 있는 모든 필드는 가급적 합께 변해야 한다. 예를 들어 특정 메소드가 수행될 떄만 사용되는 필드는 그 메소드의 지역변수로 선언되야 한다. 

```Java
setAmount(int value, String currency) {
    this.value = value;
    this.currency = currency;
}
```
위 코드는 다음과 같이 바꿀 수 있다.
```Java
setAmount(int value, String currency) {
    this.value = new Money(value, currency);
}
```
코드를 더 개선하면 다음과 같다
```Java
setAmount(Money value) {
    this.value = value;
}
```






































